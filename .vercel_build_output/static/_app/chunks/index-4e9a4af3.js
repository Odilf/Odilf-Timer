import{al as t,am as e}from"./vendor-5763a202.js";var s=[],i=[];function n(t){if(!s[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=0;s[t]=e}return s[t]}function o(t){if(!i[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=s;i[t]=e}return i[t]}function r(t,e){return t/function(t,e){if(t>e){const s=t;t=e,e=s}for(;t>0;){const s=e%t;e=t,t=s}return e}(t,e)*e}var h=class{constructor(t){this.n=t.length,this.p=t}toString(){return"Perm["+this.p.join(" ")+"]"}mul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=t.p[this.p[s]];return new h(e)}rmul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=this.p[t.p[s]];return new h(e)}inv(){const t=Array(this.n);for(let e=0;e<this.n;e++)t[this.p[e]]=e;return new h(t)}compareTo(t){for(let e=0;e<this.n;e++)if(this.p[e]!==t.p[e])return this.p[e]-t.p[e];return 0}toGap(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const i=new Array;for(let t=s;!e[t];t=this.p[t])i.push(1+t),e[t]=!0;t.push("("+i.join(",")+")")}return t.join("")}order(){let t=1;const e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;let i=0;for(let t=s;!e[t];t=this.p[t])i++,e[t]=!0;t=r(t,i)}return t}},l=class{notationToInternal(t){return t}notationToExternal(t){return t}},a=class{constructor(t,e){this.child=t,this.sw=e}notationToInternal(s){if("T"===s.family&&void 0===s.innerLayer&&void 0===s.outerLayer)return new e(new t("FLRv",s.innerLayer,s.outerLayer),s.amount);return this.child.notationToInternal(s)}notationToExternal(s){let i=s.family;return i.length>0&&"v"===i[i.length-1]&&(i=i.substring(0,i.length-1)),this.sw.spinmatch(i,"FLUR")?new e(new t("T",s.innerLayer,s.outerLayer),s.amount):this.child.notationToExternal(s)}},c=class{constructor(t,e){this.internalNames=t,this.externalNames=e}convertString(t,e,s){let i="";(t.endsWith("v")||t.endsWith("v"))&&t<="_"&&(i=t.slice(t.length-1),t=t.slice(0,t.length-1));const n=t.toUpperCase();let o=!1;return t!==n&&(o=!0,t=n),t=s.joinByFaceIndices(e.splitByFaceNames(t)),o&&(t=t.toLowerCase()),t+i}convert(s,i,n){const o=s.family,r=this.convertString(o,i,n);return o===r?s:new e(new t(r,s.innerLayer,s.outerLayer),s.amount)}notationToInternal(t){return this.convert(t,this.externalNames,this.internalNames)}notationToExternal(t){return this.convert(t,this.internalNames,this.externalNames)}},f=class{constructor(t){this.child=t}notationToInternal(s){if(void 0===s.innerLayer&&void 0===s.outerLayer){if(1===Math.abs(s.amount)){if("R++"===s.family)return new e(new t("L",3,2),-2*s.amount);if("R--"===s.family)return new e(new t("L",3,2),2*s.amount);if("D++"===s.family)return new e(new t("U",3,2),-2*s.amount);if("D--"===s.family)return new e(new t("U",3,2),2*s.amount);if("R_PLUSPLUS_"===s.family)return new e(new t("L",3,2),-2*s.amount);if("D_PLUSPLUS_"===s.family)return new e(new t("U",3,2),-2*s.amount)}if("y"===s.family)return new e("Uv",s.amount)}return this.child.notationToInternal(s)}notationToExternal(s){return"Uv"===s.family?new e(new t("y",s.innerLayer,s.outerLayer),s.amount):"Dv"===s.family?new e("y",-s.amount):this.child.notationToExternal(s)}},u=class{constructor(t){this.slices=t}notationToInternal(s){const i=s.family;return s.innerLayer||s.outerLayer||("x"===i?s=new e("Rv",s.amount):"y"===i?s=new e("Uv",s.amount):"z"===i&&(s=new e("Fv",s.amount)),1==(1&this.slices)&&("E"===i?s=new e(new t("D",(this.slices+1)/2),s.amount):"M"===i?s=new e(new t("L",(this.slices+1)/2),s.amount):"S"===i&&(s=new e(new t("F",(this.slices+1)/2),s.amount))),this.slices>2&&("e"===i?s=new e(new t("D",this.slices-1,2),s.amount):"m"===i?s=new e(new t("L",this.slices-1,2),s.amount):"s"===i&&(s=new e(new t("F",this.slices-1,2),s.amount)))),s}notationToExternal(t){const s=t.family;if(!t.innerLayer&&!t.outerLayer){if("Rv"===s)return new e("x",t.amount);if("Uv"===s)return new e("y",t.amount);if("Fv"===s)return new e("z",t.amount);if("Lv"===s)return new e("x",-t.amount);if("Dv"===s)return new e("y",-t.amount);if("Bv"===s)return new e("z",-t.amount)}return t}},m={U:"frl",L:"fld",R:"fdr",B:"dlr",u:"FRL",l:"FLD",r:"FDR",b:"DLR",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R"},p={U:"FRL",L:"FLD",R:"FDR",B:"DLR",u:"frl",l:"fld",r:"fdr",b:"dlr",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R",d:"d",f:"f",bl:"l",br:"r"},d={U:"FRL",L:"FLD",R:"FDR",B:"DLR"},g=new t("y"),b=new t("Dv"),v=class{constructor(t){this.child=t,this.wcaHack=!1,this.map=m}notationToInternal(s){if(this.wcaHack&&2===s.innerLayer&&null===s.outerLayer){const i=d[s.family];if(i)return new e(new t(i,s.innerLayer,s.outerLayer),s.amount)}const i=this.map[s.family];return i?new e(new t(i,s.innerLayer,s.outerLayer),s.amount):g.isIdentical(s.quantum)?new e(b,-s.amount):null}notationToExternal(s){if(this.wcaHack&&2===s.innerLayer&&null===s.outerLayer)for(const[i,n]of Object.entries(d))if(this.child.spinmatch(s.family,n))return new e(new t(i,s.innerLayer,s.outerLayer),s.amount);for(const[i,n]of Object.entries(this.map))if(this.child.spinmatch(s.family,n))return new e(new t(i,s.innerLayer,s.outerLayer),s.amount);return b.isIdentical(s.quantum)?new e(g,-s.amount):null}},w=class extends v{constructor(t){super(t),this.map=p}},y={U:"UBL",UL:"ULF",F:"UFR",UR:"URB",B:"DBL",D:"DFR",L:"DLF",R:"DRB",Uv:"UBLv",ULv:"ULFv",Fv:"UFRv",URv:"URBv",Bv:"DBLv",Dv:"DFRv",Lv:"DLFv",Rv:"DRBv"},x=new t("x"),z=new t("Rv"),M=new t("y"),L=new t("Uv"),k=new t("z"),F=new t("Fv"),R=class{constructor(t){this.child=t}notationToInternal(s){if(s.innerLayer||s.outerLayer)return null;const i=y[s.family];return i?new e(new t(i,s.outerLayer,s.innerLayer),s.amount):x.isIdentical(s.quantum)?new e(z,s.amount):M.isIdentical(s.quantum)?new e(L,s.amount):k.isIdentical(s.quantum)?new e(F,s.amount):null}notationToExternal(s){for(const[i,n]of Object.entries(y))if(this.child.spinmatch(s.family,n))return new e(new t(i,s.innerLayer,s.outerLayer),s.amount);return z.isIdentical(s.quantum)?new e(x,s.amount):L.isIdentical(s.quantum)?new e(M,s.amount):F.isIdentical(s.quantum)?new e(k,s.amount):null}},B=class{constructor(t,e){this.size=t,this.mod=e}reassemblySize(){return function(t){let e=1;for(;t>1;)e*=t,t--;return e}(this.size)*Math.pow(this.mod,this.size)}};function D(t,s){const i=e.fromString(s),n=t.notationToExternal(i);return null===n||i===n?s:n.toString()}var E=class{constructor(t,e,s,i,n){this.orbitnames=t,this.orbitdefs=e,this.solved=s,this.movenames=i,this.moveops=n}transformToKPuzzle(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKpuzzle();return e}static transformToKPuzzle(t,e){const s={};for(let i=0;i<t.length;i++)s[t[i]]=e.orbits[i].toKpuzzle();return s}toKsolve(t,e=new l){const s=[];s.push("Name "+t),s.push("");for(let i=0;i<this.orbitnames.length;i++)s.push("Set "+this.orbitnames[i]+" "+this.orbitdefs[i].size+" "+this.orbitdefs[i].mod);s.push(""),s.push("Solved");for(let i=0;i<this.orbitnames.length;i++)this.solved.orbits[i].appendConciseDefinition(s,this.orbitnames[i],!1);s.push("End");for(let i=0;i<this.movenames.length;i++){s.push("");let t=D(e,this.movenames[i]),n=!1;"'"===t[t.length-1]&&(n=!0,t=t.substring(0,t.length-1)),s.push("Move "+t);for(let e=0;e<this.orbitnames.length;e++)n?this.moveops[i].orbits[e].inv().appendConciseDefinition(s,this.orbitnames[e],!0):this.moveops[i].orbits[e].appendConciseDefinition(s,this.orbitnames[e],!0);s.push("End")}return s}toKpuzzle(){const t={},e={};for(let i=0;i<this.orbitnames.length;i++)t[this.orbitnames[i]]={numPieces:this.orbitdefs[i].size,orientations:this.orbitdefs[i].mod},e[this.orbitnames[i]]=this.solved.orbits[i].toKpuzzle();const s={};for(let i=0;i<this.movenames.length;i++)s[this.movenames[i]]=this.transformToKPuzzle(this.moveops[i]);return{name:"PG3D",orbits:t,startPieces:e,moves:s}}optimize(){const t=[],e=[],s=[],i=[];for(let n=0;n<this.moveops.length;n++)i.push([]);for(let n=0;n<this.orbitdefs.length;n++){const o=this.orbitdefs[n].mod,r=this.orbitdefs[n].size,h=new T(r),l=new Array(this.orbitdefs[n].size);for(let t=0;t<r;t++)l[t]=!1;for(let t=0;t<this.moveops.length;t++)for(let e=0;e<r;e++)this.moveops[t].orbits[n].perm[e]===e&&0===this.moveops[t].orbits[n].ori[e]||(l[e]=!0,h.union(e,this.moveops[t].orbits[n].perm[e]));let a=!0;if(o>1){a=!1;const t=new T(this.orbitdefs[n].size*o);for(let e=0;e<this.moveops.length;e++)for(let s=0;s<r;s++)if(this.moveops[e].orbits[n].perm[s]!==s||0!==this.moveops[e].orbits[n].ori[s])for(let i=0;i<o;i++)t.union(s*o+i,this.moveops[e].orbits[n].perm[s]*o+(i+this.moveops[e].orbits[n].ori[s])%o);for(let e=0;!a&&e<r;e++)for(let s=1;s<o;s++)t.find(e*o)===t.find(e*o+s)&&(a=!0);for(let e=0;!a&&e<r;e++)for(let t=0;t<e;t++)this.solved.orbits[n].perm[e]===this.solved.orbits[n].perm[t]&&(a=!0)}let c=-1,f=!1;for(let t=0;t<this.orbitdefs[n].size;t++)if(l[t]){const e=h.find(t);c<0?c=e:c!==e&&(f=!0)}for(let u=0;u<this.orbitdefs[n].size;u++){if(!l[u])continue;if(h.find(u)!==u)continue;const o=[],r=[];let c=0;for(let t=0;t<this.orbitdefs[n].size;t++)h.find(t)===u&&(o[c]=t,r[t]=c,c++);if(f?t.push(this.orbitnames[n]+"_p"+u):t.push(this.orbitnames[n]),a){e.push(new B(c,this.orbitdefs[n].mod)),s.push(this.solved.orbits[n].remapVS(o,c));for(let t=0;t<this.moveops.length;t++)i[t].push(this.moveops[t].orbits[n].remap(o,r,c))}else{e.push(new B(c,1)),s.push(this.solved.orbits[n].remapVS(o,c).killOri());for(let t=0;t<this.moveops.length;t++)i[t].push(this.moveops[t].orbits[n].remap(o,r,c).killOri())}}}return new E(t,e,new I(s),this.movenames,i.map((t=>new S(t))))}scramble(t){const e=[];for(let i=0;i<this.moveops.length;i++)e[i]=this.moveops[i];for(let i=0;i<e.length;i++){const t=Math.floor(Math.random()*e.length),s=e[i];e[i]=e[t],e[t]=s}t<e.length&&(t=e.length);for(let i=0;i<t;i++){const t=Math.floor(Math.random()*e.length),s=Math.floor(Math.random()*e.length),i=Math.floor(Math.random()*this.moveops.length);e[t]=e[t].mul(e[s]).mul(this.moveops[i]),Math.random()<.1&&(e[t]=e[t].mul(this.moveops[i]))}let s=e[0];for(let i=1;i<e.length;i++)s=s.mul(e[i]);this.solved=this.solved.mul(s)}reassemblySize(){let t=1;for(let e=0;e<this.orbitdefs.length;e++)t*=this.orbitdefs[e].reassemblySize();return t}},C=class{constructor(t,e,s){this.perm=t,this.ori=e,this.orimod=s}static e(t,e){return new C(o(t),n(t),e)}mul(t){const e=this.perm.length,s=new Array(e);if(1===this.orimod){for(let i=0;i<e;i++)s[i]=this.perm[t.perm[i]];return new C(s,this.ori,this.orimod)}{const i=new Array(e);for(let n=0;n<e;n++)s[n]=this.perm[t.perm[n]],i[n]=(this.ori[t.perm[n]]+t.ori[n])%this.orimod;return new C(s,i,this.orimod)}}inv(){const t=this.perm.length,e=new Array(t),s=new Array(t);for(let i=0;i<t;i++)e[this.perm[i]]=i,s[this.perm[i]]=(this.orimod-this.ori[i])%this.orimod;return new C(e,s,this.orimod)}equal(t){const e=this.perm.length;for(let s=0;s<e;s++)if(this.perm[s]!==t.perm[s]||this.ori[s]!==t.ori[s])return!1;return!0}killOri(){const t=this.perm.length;for(let e=0;e<t;e++)this.ori[e]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(1===t)return new h(this.perm);const e=this.perm.length,s=new Array(e*t);for(let i=0;i<e;i++)for(let e=0;e<t;e++)s[i*t+e]=t*this.perm[i]+(this.ori[i]+e)%t;return new h(s)}identicalPieces(){const t=[],e=this.perm.length,s=[];for(let i=0;i<e;i++){const n=this.perm[i];if(void 0===t[n]){const o=[i];t[n]=!0;for(let t=i+1;t<e;t++)this.perm[t]===n&&o.push(t);s.push(o)}}return s}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;if(this.perm===o(t)&&this.ori===n(t))return!0;for(let e=0;e<t;e++)if(this.perm[e]!==e||0!==this.ori[e])return!1;return!0}zeroOris(){const t=this.perm.length;if(this.ori===n(t))return!0;for(let e=0;e<t;e++)if(0!==this.ori[e])return!1;return!0}remap(t,e,s){const i=new Array(s),n=new Array(s);for(let o=0;o<s;o++)i[o]=e[this.perm[t[o]]],n[o]=this.ori[t[o]];return new C(i,n,this.orimod)}remapVS(t,e){const s=new Array(e),i=new Array(e);let n=0;const o=[];for(let r=0;r<e;r++){const e=this.perm[t[r]];void 0===o[e]&&(o[e]=n++),s[r]=o[e],i[r]=this.ori[t[r]]}return new C(s,i,this.orimod)}appendConciseDefinition(t,e,s){if(!this.isIdentity()&&(t.push(e),t.push(this.perm.map((t=>t+1)).join(" ")),!this.zeroOris()))if(s){const e=new Array(this.ori.length);for(let t=0;t<e.length;t++)e[this.perm[t]]=this.ori[t];t.push(e.join(" "))}else t.push(this.ori.join(" "))}toKpuzzle(){const t=this.perm.length;return this.isIdentity()?(C.kcache[t]||(C.kcache[t]={permutation:o(t),orientation:n(t)}),C.kcache[t]):{permutation:this.perm,orientation:this.ori}}},U=C;U.kcache=[];var N=class{constructor(t){this.orbits=t}internalMul(t){const e=[];for(let s=0;s<this.orbits.length;s++)e.push(this.orbits[s].mul(t.orbits[s]));return e}internalInv(){const t=[];for(let e=0;e<this.orbits.length;e++)t.push(this.orbits[e].inv());return t}equal(t){for(let e=0;e<this.orbits.length;e++)if(!this.orbits[e].equal(t.orbits[e]))return!1;return!0}killOri(){for(let t=0;t<this.orbits.length;t++)this.orbits[t].killOri();return this}toPerm(){const t=new Array;let e=0;for(let i=0;i<this.orbits.length;i++){const s=this.orbits[i].toPerm();t.push(s),e+=s.n}const s=new Array(e);e=0;for(let i=0;i<this.orbits.length;i++){const n=t[i];for(let t=0;t<n.n;t++)s[e+t]=e+n.p[t];e+=n.n}return new h(s)}identicalPieces(){const t=[];let e=0;for(let s=0;s<this.orbits.length;s++){const i=this.orbits[s].orimod,n=this.orbits[s].identicalPieces();for(let s=0;s<n.length;s++)t.push(n[s].map((t=>t*i+e)));e+=i*this.orbits[s].perm.length}return t}order(){let t=1;for(let e=0;e<this.orbits.length;e++)t=r(t,this.orbits[e].order());return t}},S=class extends N{constructor(t){super(t)}mul(t){return new S(this.internalMul(t))}mulScalar(t){if(0===t)return this.e();let e=this;for(t<0&&(e=e.inv(),t=-t);0==(1&t);)e=e.mul(e),t>>=1;if(1===t)return e;let s=e,i=this.e();for(;t>0;)1&t&&(i=i.mul(s)),t>1&&(s=s.mul(s)),t>>=1;return i}inv(){return new S(this.internalInv())}e(){return new S(this.orbits.map((t=>U.e(t.perm.length,t.orimod))))}},I=class extends N{constructor(t){super(t)}mul(t){return new I(this.internalMul(t))}},T=class{constructor(t){this.n=t,this.heads=new Array(t);for(let e=0;e<t;e++)this.heads[e]=e}find(t){let e=this.heads[t];return this.heads[e]===e||(e=this.find(this.heads[e]),this.heads[t]=e),e}union(t,e){const s=this.find(t),i=this.find(e);s<i?this.heads[i]=s:s>i&&(this.heads[s]=i)}};var O=class{constructor(t,e){this.facenames=t,this.prefixFree=!0,this.gripnames=[],e&&(this.gripnames=e);for(let s=0;this.prefixFree&&s<t.length;s++)for(let e=0;this.prefixFree&&e<t.length;e++)s!==e&&t[s].startsWith(t[e])&&(this.prefixFree=!1)}setGripNames(t){this.gripnames=t}splitByFaceNames(t){const e=[];let s=0;for(;s<t.length;){s>0&&s<t.length&&"_"===t[s]&&s++;let i=-1;for(let e=0;e<this.facenames.length;e++)t.substr(s).startsWith(this.facenames[e])&&(i<0||this.facenames[e].length>this.facenames[i].length)&&(i=e);if(!(i>=0))throw new Error("Could not split "+t+" into face names.");e.push(i),s+=this.facenames[i].length}return e}joinByFaceIndices(t){let e="";const s=[];for(let i=0;i<t.length;i++)s.push(e),s.push(this.facenames[t[i]]),this.prefixFree||(e="_");return s.join("")}spinmatch(t,e){if(t===e)return!0;try{const s=this.splitByFaceNames(t),i=this.splitByFaceNames(e);if(s.length!==i.length&&s.length<3)return!1;for(let t=0;t<s.length;t++){for(let i=0;i<t;i++)if(s[t]===s[i])return!1;let e=!1;for(let n=0;n<i.length;n++)if(s[t]===i[n]){e=!0;break}if(!e)return!1}return!0}catch(s){return!1}}unswizzle(t){(t.endsWith("v")||t.endsWith("w"))&&t[0]<="Z"&&(t=t.slice(0,t.length-1));const e=t.toUpperCase();for(let s=0;s<this.gripnames.length;s++){const t=this.gripnames[s];if(this.spinmatch(e,t))return t}return t}},P={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333","40x40x40":"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547","curvy copter":"c e 0.83",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667",tetraminx:"t v 0.333333333333333","master pyraminx":"t v 0 v 1 v 2","master tetraminx":"t v 0 v 1","professor pyraminx":"t v -0.2 v 0.6 v 1.4 v 2.2","professor tetraminx":"t v -0.2 v 0.6 v 1.4","Jing pyraminx":"t f 0","master pyramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",teraminx:"d f 0.64 f 0.76 f 0.88",petaminx:"d f 0.64 f 0.73 f 0.82 f 0.91",examinx:"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",zetaminx:"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",yottaminx:"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",pentultimate:"d f 0","master pentultimate":"d f 0.1","elite pentultimate":"d f 0 f 0.145905",starminx:"d v 0.937962370425399","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","master FTO":"o f 0.5 f 0","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","icosahedron 2":"i v 0.18759247376021","icosahedron 3":"i v 0.18759247376021 e 0","icosahedron static faces":"i v 0.84","icosahedron moving faces":"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.937962370425399"};function j(t){let e=new K(0,0,0,0);for(let s=0;s<t.length;s++)e=e.sum(t[s]);return e.smul(1/t.length)}function A(t,e,s,i){const n=i[t].intersect3(i[e],i[s]);if(!n)return n;for(let o=0;o<i.length;o++)if(o!==t&&o!==e&&o!==s){const t=i[o].b*n.b+i[o].c*n.c+i[o].d*n.d;if(i[o].a>0&&t>i[o].a||i[o].a<0&&t<i[o].a)return!1}return n}var q=class{constructor(t,e,s){this.face=t,this.left=e,this.right=s}split(t){var e,s;const i=t.cutface(this.face);return null!==i&&(void 0===this.left?(this.left=new q(i[0]),this.right=new q(i[1])):(this.left=null==(e=this.left)?void 0:e.split(t),this.right=null==(s=this.right)?void 0:s.split(t))),this}collect(t,e){var s,i,n,o;return void 0===this.left?t.push(this.face):e?(null==(s=this.left)||s.collect(t,!1),null==(i=this.right)||i.collect(t,!0)):(null==(n=this.right)||n.collect(t,!1),null==(o=this.left)||o.collect(t,!0)),t}},K=class{constructor(t,e,s,i){this.a=t,this.b=e,this.c=s,this.d=i}mul(t){return new K(this.a*t.a-this.b*t.b-this.c*t.c-this.d*t.d,this.a*t.b+this.b*t.a+this.c*t.d-this.d*t.c,this.a*t.c-this.b*t.d+this.c*t.a+this.d*t.b,this.a*t.d+this.b*t.c-this.c*t.b+this.d*t.a)}toString(){return"Q["+this.a+","+this.b+","+this.c+","+this.d+"]"}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(t){return new K(0,this.c*t.d-this.d*t.c,this.d*t.b-this.b*t.d,this.b*t.c-this.c*t.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const t=Math.sqrt(this.dot(this));return new K(this.a/t,this.b/t,this.c/t,this.d/t)}makenormal(){return new K(0,this.b,this.c,this.d).normalize()}normalizeplane(){const t=Math.hypot(this.b,this.c,this.d);return new K(this.a/t,this.b/t,this.c/t,this.d/t)}smul(t){return new K(this.a*t,this.b*t,this.c*t,this.d*t)}sum(t){return new K(this.a+t.a,this.b+t.b,this.c+t.c,this.d+t.d)}sub(t){return new K(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new K(this.a,-this.b,-this.c,-this.d)}det3x3(t,e,s,i,n,o,r,h,l){return t*(n*l-o*h)+e*(o*r-i*l)+s*(i*h-n*r)}rotateplane(t){const e=t.mul(new K(0,this.b,this.c,this.d)).mul(t.invrot());return e.a=this.a,e}orthogonal(){const t=Math.abs(this.b),e=Math.abs(this.c),s=Math.abs(this.d);return t<e&&t<s?this.cross(new K(0,1,0,0)).normalize():e<t&&e<s?this.cross(new K(0,0,1,0)).normalize():this.cross(new K(0,0,0,1)).normalize()}pointrotation(t){const e=this.normalize();if(t=t.normalize(),e.sub(t).len()<1e-9)return new K(1,0,0,0);let s=e.sum(t);s=s.len()<1e-9?s.orthogonal():s.normalize();const i=e.cross(s);return i.a=e.dot(s),i}unproject(t){return this.sum(t.smul(-this.dot(t)/(this.len()*t.len())))}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){return t.map((t=>t.rotatepoint(this)))}rotatecubie(t){return t.map((t=>this.rotateface(t)))}intersect3(t,e){const s=this.det3x3(this.b,this.c,this.d,t.b,t.c,t.d,e.b,e.c,e.d);return!(Math.abs(s)<1e-9)&&new K(0,this.det3x3(this.a,this.c,this.d,t.a,t.c,t.d,e.a,e.c,e.d)/s,this.det3x3(this.b,this.a,this.d,t.b,t.a,t.d,e.b,e.a,e.d)/s,this.det3x3(this.b,this.c,this.a,t.b,t.c,t.a,e.b,e.c,e.a)/s)}side(t){return t>1e-9?1:t<-1e-9?-1:0}cutface(t){const e=this.a;let s=0,i=null;for(let n=0;n<t.length;n++)s|=1<<this.side(t[n].dot(this)-e)+1;if(5==(5&s)){i=[];const s=t.map((t=>this.side(t.dot(this)-e)));for(let n=-1;n<=1;n+=2){const o=[];for(let i=0;i<t.length;i++){s[i]!==n&&0!==s[i]||o.push(t[i]);const r=(i+1)%t.length;if(s[i]+s[r]===0&&0!==s[i]){const s=t[i].dot(this)-e,n=s/(s-(t[r].dot(this)-e)),h=t[i].smul(1-n).sum(t[r].smul(n));o.push(h)}}i.push(o)}}return i}cutfaces(t){const e=[];for(let s=0;s<t.length;s++){const i=t[s],n=this.cutface(i);n?(e.push(n[0]),e.push(n[1])):e.push(i)}return e}faceside(t){const e=this.a;for(let s=0;s<t.length;s++){const i=this.side(t[s].dot(this)-e);if(0!==i)return i}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const e=this.normalize(),s=t.normalize();return e.dist(s)<1e-9||e.dist(s.smul(-1))<1e-9}makecut(t){return new K(t,this.b,this.c,this.d)}};function G(t,e){const s=[],i=[];for(let n=0;n<e.length;n++){const o=t.rotateplane(e[n]);let r=!1;for(let t=0;t<s.length;t++)if(o.dist(s[t])<1e-9){r=!0;break}r||(s.push(o),i.push(e[n]))}return i}function _(t){const e=[];for(let s=1;s<t.length;s++)for(let i=s+1;i<t.length;i++){const n=A(0,s,i,t);if(n){let t=!1;for(let s=0;s<e.length;s++)if(n.dist(e[s])<1e-9){t=!0;break}t||e.push(n)}}for(;;){let s=!1;for(let i=0;i<e.length;i++){const n=(i+1)%e.length;if(t[0].dot(e[i].cross(e[n]))<0){const t=e[i];e[i]=e[n],e[n]=t,s=!0}}if(!s)break}return e}var W=!0;function H(t){W=t}function J(t,e){for(let s=0;s<t.length;s++)if(t[s][0].dist(e)<1e-9)return s;throw new Error("Element not found")}function Q(){return P}function V(t){return P[t]}function Z(t){const e=t.split(/ /).filter(Boolean);if(e.length%2==0)return!1;if("o"!==e[0]&&"c"!==e[0]&&"i"!==e[0]&&"d"!==e[0]&&"t"!==e[0])return!1;const s=[];for(let i=1;i<e.length;i+=2){if("f"!==e[i]&&"v"!==e[i]&&"e"!==e[i])return!1;s.push([e[i],e[i+1]])}return[e[0],s]}function $(t,e=[]){const[s,i]=Z(t),n=new nt(s,i,["allmoves","true"].concat(e));return n.allstickers(),n.genperms(),n}function X(t,e=[]){return $(P[t],e)}function Y(t,e,s){let i=!1;s-e[1]<e[0]&&(t=[t[2],t[3],t[0],t[1]],e=[s-e[1],s-e[0]],i=!0);let n=t[0],o="";if(0===e[0]&&e[1]===s)n+="v";else if(e[0]===e[1])e[1]>0&&(o=String(e[1]+1));else{if(0!==e[0])throw"We only support slice and outer block moves right now. "+e;n=n.toLowerCase(),e[1]>1&&(o=String(e[1]+1))}return[o+n,i]}function tt(t,e){const s=[];let i=0;for(;i<t.length;){i>0&&i<t.length&&"_"===t[i]&&i++;let n="";for(let s=0;s<e.length;s++)t.substr(i).startsWith(e[s][1])&&e[s][1].length>n.length&&(n=e[s][1]);if(""===n)throw new Error("Could not split "+t+" into face names.");s.push(n),i+=n.length}return s}function et(t,e){return[t.b/e,-t.c/e,t.d/e]}function st(t,e){const s=[],i=t.length;for(let n=0;n<i;n++)s[i-n-1]=et(t[n],e);return s}function it(t,e){const s=[];for(let i=1;i<10;i++){for(let n=0;n<t.length;n++){const i=(n+t.length-1)%t.length,o=(n+1)%t.length,r=t[i].sub(t[n]).normalize(),h=t[o].sub(t[n]).normalize(),l=r.dot(h),a=e/Math.sqrt(1-l*l);s[n]=t[n].sum(r.sum(h).smul(a))}let i=!0;for(let e=0;i&&e<s.length;e++){const n=(e+t.length-1)%t.length,o=(e+1)%t.length;s[n].sub(s[e]).cross(s[o].sub(s[e])).dot(s[e])>=0&&(i=!1)}if(i)return s;e/=2}return t}var nt=class{constructor(t,e,s){function i(t){return"string"==typeof t?JSON.parse(t):t}function n(t){return"string"==typeof t?"false"!==t:!!t}if(this.args="",this.cmovesbyslice=[],this.verbose=0,this.allmoves=!1,this.cornersets=!0,this.centersets=!0,this.edgesets=!0,this.omitsets=[],this.graycorners=!1,this.graycenters=!1,this.grayedges=!1,this.killorientation=!1,this.optimize=!1,this.scramble=0,this.fixPiece="",this.orientCenters=!1,this.duplicatedFaces=[],this.duplicatedCubies=[],this.fixedCubie=-1,this.net=[],this.colors=[],this.faceorder=[],this.faceprecedence=[],this.notationMapper=new l,this.addNotationMapper="",this.setReidOrder=!1,void 0!==s){if(s.length%2!=0)throw new Error("Odd length in option list?");for(let t=0;t<s.length;t+=2)if("verbose"===s[t])this.verbose++;else if("quiet"===s[t])this.verbose=0;else if("allmoves"===s[t])this.allmoves=n(s[t+1]);else if("outerblockmoves"===s[t])this.outerblockmoves=n(s[t+1]);else if("vertexmoves"===s[t])this.vertexmoves=n(s[t+1]);else if("rotations"===s[t])this.addrotations=n(s[t+1]);else if("cornersets"===s[t])this.cornersets=n(s[t+1]);else if("centersets"===s[t])this.centersets=n(s[t+1]);else if("edgesets"===s[t])this.edgesets=n(s[t+1]);else if("omit"===s[t])this.omitsets=s[t+1];else if("graycorners"===s[t])this.graycorners=n(s[t+1]);else if("graycenters"===s[t])this.graycenters=n(s[t+1]);else if("grayedges"===s[t])this.grayedges=n(s[t+1]);else if("movelist"===s[t])this.movelist=i(s[t+1]);else if("killorientation"===s[t])this.killorientation=n(s[t+1]);else if("optimize"===s[t])this.optimize=n(s[t+1]);else if("scramble"===s[t])this.scramble=s[t+1];else if("fix"===s[t])this.fixPiece=s[t+1];else if("orientcenters"===s[t])this.orientCenters=n(s[t+1]);else if("puzzleorientation"===s[t])this.puzzleOrientation=i(s[t+1]);else{if("puzzleorientations"!==s[t])throw new Error("Bad option while processing option list "+s[t]);this.puzzleOrientations=i(s[t+1])}}this.args=t+" "+e.map((t=>t.join(" "))).join(" "),s&&(this.args+=" "+s.join(" ")),this.verbose>0&&console.log(this.header("# ")),this.create(t,e)}create(t,e){this.moveplanes=[],this.moveplanes2=[],this.faces=[],this.cubies=[];let s=null;switch(t){case"c":s=function(){const t=Math.sqrt(.5);return[new K(t,t,0,0),new K(t,0,t,0)]}();break;case"o":s=function(){const t=Math.sqrt(.5);return[new K(.5,.5,.5,.5),new K(t,0,0,t)]}();break;case"i":s=function(){let t=1/6+Math.sqrt(5)/6,e=2/3+Math.sqrt(5)/3;const s=Math.sqrt(t*t+e*e);t/=s,e/=s;const i=2*Math.PI/6;return[new K(Math.cos(i),t*Math.sin(i),e*Math.sin(i),0),new K(Math.cos(i),-t*Math.sin(i),e*Math.sin(i),0)]}();break;case"t":s=[new K(.5,.5,.5,.5),new K(.5,.5,.5,-.5)];break;case"d":s=function(){const t=2*Math.PI/10;let e=.5+.3*Math.sqrt(5),s=.5+.1*Math.sqrt(5);const i=Math.sqrt(e*e+s*s);return e/=i,s/=i,[new K(Math.cos(t),e*Math.sin(t),s*Math.sin(t),0),new K(.5,.5,.5,.5)]}();break;default:throw new Error("Bad shape argument: "+t)}this.rotations=function(t){const e=[new K(1,0,0,0)];for(let s=0;s<e.length;s++)for(let i=0;i<t.length;i++){const n=t[i].mul(e[s]),o=n.smul(-1);let r=!1;for(let t=0;t<e.length;t++)if(n.dist(e[t])<1e-9||o.dist(e[t])<1e-9){r=!0;break}r||e.push(n)}return e}(s),this.verbose&&console.log("# Rotations: "+this.rotations.length);const i=s[0];this.baseplanerot=G(i,this.rotations);const n=this.baseplanerot.map((t=>i.rotateplane(t)));this.baseplanes=n,this.basefacecount=n.length;const o={4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","BR",""],["BR","D","","BB"],["BB","BR","U","BL"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]}[n.length];this.net=o,this.colors={4:{F:"#00ff00",D:"#ffff00",L:"#ff0000",R:"#0000ff"},6:{U:"#ffffff",F:"#00ff00",R:"#ff0000",D:"#ffff00",B:"#0000ff",L:"#ff8000"},8:{U:"#ffffff",F:"#ff0000",R:"#00bb00",D:"#ffff00",BB:"#1122ff",L:"#9524c5",BL:"#ff8800",BR:"#aaaaaa"},12:{U:"#ffffff",F:"#006633",R:"#ff0000",C:"#ffffd0",A:"#3399ff",L:"#660099",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#ffff00",I:"#ff6633",D:"#999999"},20:{R:"#db69f0",C:"#178fde",F:"#23238b",E:"#9cc726",L:"#2c212d",U:"#177fa7",A:"#e0de7f",G:"#2b57c0",I:"#41126b",S:"#4b8c28",H:"#7c098d",J:"#7fe7b4",B:"#85fb74",K:"#3f4bc3",D:"#0ff555",M:"#f1c2c8",O:"#58d340",P:"#c514f2",N:"#14494e",Q:"#8b1be1"}}[n.length],this.faceorder={4:["F","D","L","R"],6:["U","D","F","B","L","R"],8:["F","BB","D","U","BR","L","R","BL"],12:["L","E","F","BF","R","I","U","D","BR","A","BL","C"],20:["L","S","E","O","F","B","I","P","R","K","U","D","J","A","Q","H","G","N","M","C"]}[n.length],this.verbose&&console.log("# Base planes: "+n.length);const r=_(n),h=new K(0,0,0,0);this.verbose&&console.log("# Face vertices: "+r.length);const l=n[0].makenormal(),a=r[0].sum(r[1]).makenormal(),f=r[0].makenormal(),u=new K(1,l.b,l.c,l.d);this.verbose&&console.log("# Boundary is "+u);let m=[_(G(u,this.rotations).map((t=>u.rotateplane(t))))];this.edgedistance=m[0][0].sum(m[0][1]).smul(.5).dist(h),this.vertexdistance=m[0][0].dist(h);const p=[],d=[];let g=!1,b=!1,v=!1;for(let c=0;c<e.length;c++){let t=null,s=0;switch(e[c][0]){case"f":t=l,s=1,g=!0;break;case"v":t=f,s=this.vertexdistance,v=!0;break;case"e":t=a,s=this.edgedistance,b=!0;break;default:throw new Error("Bad cut argument: "+e[c][0])}p.push(t.makecut(Number(e[c][1]))),d.push(e[c][1]<s)}this.addrotations&&(g||p.push(l.makecut(10)),v||p.push(f.makecut(10)),b||p.push(a.makecut(10))),this.basefaces=[];for(let c=0;c<this.baseplanerot.length;c++){const t=this.baseplanerot[c].rotateface(m[0]);this.basefaces.push(t)}const w=[],y=[],x=[],z=[],M=m[0].length;function L(t,e,s){for(let i=0;i<t.length;i++)if(t[i][0].dist(e)<1e-9)return void t[i].push(s);t.push([e,s])}for(let c=0;c<this.baseplanerot.length;c++){const t=this.baseplanerot[c].rotateface(m[0]);for(let e=0;e<t.length;e++){const s=(e+1)%t.length;L(z,t[e].sum(t[s]).smul(.5),c)}}const k=[];for(let c=0;c<this.baseplanerot.length;c++){const t=this.baseplanerot[c].rotateface(m[0]),e=[];for(let s=0;s<t.length;s++){const i=(s+1)%t.length,n=z[J(z,t[s].sum(t[i]).smul(.5))];if(c===n[1])e.push(n[2]);else{if(c!==n[2])throw new Error("Could not find edge");e.push(n[1])}}k.push(e)}const F={},R=[];R.push(o[0][0]),F[o[0][0]]=0,R[k[0][0]]=o[0][1],F[o[0][1]]=k[0][0];for(let c=0;c<o.length;c++){const t=F[o[c][0]];if(void 0===t)throw new Error("Bad edge description; first edge not connected");let e=-1;for(let s=0;s<k[t].length;s++){const i=R[k[t][s]];if(void 0!==i&&i===o[c][1]){e=s;break}}if(e<0)throw new Error("First element of a net not known");for(let s=2;s<o[c].length;s++){if(""===o[c][s])continue;const i=k[t][(s+e-1)%M],n=R[i];if(void 0!==n&&n!==o[c][s])throw new Error("Face mismatch in net");R[i]=o[c][s],F[o[c][s]]=i}}for(let c=0;c<R.length;c++){let t=!1;for(let e=0;e<this.faceorder.length;e++)if(R[c]===this.faceorder[e]){this.faceprecedence[c]=e,t=!0;break}if(!t)throw new Error("Could not find face "+R[c]+" in face order list "+this.faceorder)}for(let c=0;c<this.baseplanerot.length;c++){const t=this.baseplanerot[c].rotateface(m[0]),e=u.rotateplane(this.baseplanerot[c]),s=R[c];w.push([t,s]),y.push([e,s])}for(let c=0;c<this.baseplanerot.length;c++){const t=this.baseplanerot[c].rotateface(m[0]),e=R[c];for(let s=0;s<t.length;s++){const i=(s+1)%t.length,n=t[s].sum(t[i]).smul(.5),o=(s+2)%t.length,r=t[i].sum(t[o]).smul(.5),h=J(z,n),l=J(z,r);L(x,t[i],[e,l,h])}}this.swizzler=new O(w.map((t=>t[1])));const B=this.swizzler.prefixFree?"":"_";for(let c=0;c<z.length;c++){if(3!==z[c].length)throw new Error("Bad length in edge names "+z[c]);let t=R[z[c][1]];const e=R[z[c][2]];t=this.faceprecedence[z[c][1]]<this.faceprecedence[z[c][2]]?t+B+e:e+B+t,z[c]=[z[c][0],t]}this.cornerfaces=x[0].length-1;for(let c=0;c<x.length;c++){if(x[c].length<4)throw new Error("Bad length in vertex names");let t=1;for(let s=2;s<x[c].length;s++)this.faceprecedence[F[x[c][s][0]]]<this.faceprecedence[F[x[c][t][0]]]&&(t=s);let e="";for(let s=1;s<x[c].length;s++){e=1===s?x[c][t][0]:e+B+x[c][t][0];for(let e=1;e<x[c].length;e++)if(x[c][t][1]===x[c][e][2]){t=e;break}}x[c]=[x[c][0],e]}this.verbose>1&&(console.log("# Face precedence list: "+this.faceorder.join(" ")),console.log("# Face names: "+w.map((t=>t[1])).join(" ")),console.log("# Edge names: "+z.map((t=>t[1])).join(" ")),console.log("# Vertex names: "+x.map((t=>t[1])).join(" ")));const D=[];for(let c=0;c<y.length;c++)D.push([y[c][0].makenormal(),y[c][1],"f"]);for(let c=0;c<z.length;c++)D.push([z[c][0].makenormal(),z[c][1],"e"]);for(let c=0;c<x.length;c++)D.push([x[c][0].makenormal(),x[c][1],"v"]);this.facenames=w,this.faceplanes=y,this.edgenames=z,this.vertexnames=x,this.geonormals=D;const E=D.map((t=>t[1]));this.swizzler.setGripNames(E),this.verbose&&console.log("# Distances: face 1 edge "+this.edgedistance+" vertex "+this.vertexdistance);for(let c=0;c<p.length;c++)for(let t=0;t<this.rotations.length;t++){const e=p[c].rotateplane(this.rotations[t]);let s=!1;for(let t=0;t<this.moveplanes.length;t++)if(e.sameplane(this.moveplanes[t])){s=!0;break}s||(this.moveplanes.push(e),d[c]&&this.moveplanes2.push(e))}let C=new q(m[0]);const U=this.moveplanes2.slice();let N=31;for(let c=0;c<U.length;c++){const t=c+Math.floor((U.length-c)*(N/65536));C=C.split(U[t]),U[t]=U[c],N=(1657*N+101)%65536}m=C.collect([],!0),this.faces=m,this.verbose&&console.log("# Faces is now "+m.length),this.stickersperface=m.length;let S=1e99;for(let c=0;c<m.length;c++)for(let t=0;t<m[c].length;t++){const e=(t+1)%m[c].length,s=m[c][t].dist(m[c][e]);s<S&&(S=s)}this.shortedge=S,this.verbose&&console.log("# Short edge is "+S),"c"!==t||!g||b||v||(this.addNotationMapper="NxNxNCubeMapper",this.setReidOrder=!0),"c"!==t||!v||g||b||(this.addNotationMapper="SkewbMapper"),"t"!==t||!v&&!g||b||(this.addNotationMapper="PyraminxOrTetraminxMapper"),"o"===t&&g&&W&&(this.notationMapper=new c(this.swizzler,new O(["F","D","L","BL","R","U","BR","B"])),b||v||(this.addNotationMapper="FTOMapper")),"d"===t&&g&&W&&(this.addNotationMapper="MegaminxMapper",this.notationMapper=new c(this.swizzler,new O(["U","F","L","BL","BR","R","FR","FL","DL","B","DR","D"])))}keyface(t){return this.keyface2(j(t))}keyface2(t){let e="";for(let s=0;s<this.moveplanesets.length;s++)if(this.moveplanesets[s].length>0){const i=t.dot(this.moveplanesets[s][0]);let n=0,o=1;for(;2*o<=this.moveplanesets[s].length;)o*=2;for(;o>0;o>>=1)n+o<=this.moveplanesets[s].length&&i>this.moveplanesets[s][n+o-1].a&&(n+=o);n<=90?e+=String.fromCharCode(34+n):e=e+"!"+String.fromCharCode(34+Math.floor(n/90))+String.fromCharCode(34+n%90)}return e}findface(t){const e=j(t),s=this.keyface2(e),i=this.facelisthash[s];if(1===i.length)return i[0];for(let n=0;n+1<i.length;n++){const t=this.facelisthash[s][n];if(Math.abs(e.dist(this.facecentermass[t]))<1e-9)return t}return i[i.length-1]}findface2(t){const e=this.keyface2(t),s=this.facelisthash[e];if(1===s.length)return s[0];for(let i=0;i+1<s.length;i++){const s=this.facelisthash[e][i];if(Math.abs(t.dist(this.facecentermass[s]))<1e-9)return s}return s[s.length-1]}project2d(t,e,s){const i=this.facenames[t][0],n=(e+1)%i.length,o=this.baseplanes[t];let r=i[n].sub(i[e]);const h=r.len();r=r.normalize();const l=r.cross(o).normalize();let a=s[1].sub(s[0]);const c=a.len()/h;a=a.normalize();const f=a.b,u=a.c,m=r.smul(f).sub(l.smul(u)).smul(c),p=l.smul(f).sum(r.smul(u)).smul(c),d=new K(0,s[0].b-m.dot(i[e]),s[0].c-p.dot(i[e]),0);return[m,p,d]}allstickers(){this.faces=function(t,e){const s=[];for(let i=0;i<t.length;i++)for(let n=0;n<e.length;n++){const o=e[n],r=[];for(let e=0;e<o.length;e++)r.push(o[e].rotateplane(t[i]));s.push(r)}return s}(this.baseplanerot,this.faces),this.verbose&&console.log("# Total stickers is now "+this.faces.length),this.facecentermass=new Array(this.faces.length);for(let a=0;a<this.faces.length;a++)this.facecentermass[a]=j(this.faces[a]);const t=[],e=[];for(let a=0;a<this.moveplanes.length;a++){const s=this.moveplanes[a].makenormal();let i=!1;for(let t=0;t<e.length;t++)s.sameplane(e[t].makenormal())&&(i=!0);i||(e.push(s),t.push([]))}for(let a=0;a<this.moveplanes2.length;a++){const s=this.moveplanes2[a],i=s.makenormal();for(let n=0;n<e.length;n++)if(i.sameplane(e[n])){t[n].push(s);break}}for(let a=0;a<t.length;a++){const s=t[a].map((t=>t.normalizeplane())),i=e[a];for(let t=0;t<s.length;t++)s[t].makenormal().dist(i)>1e-9&&(s[t]=s[t].smul(-1));s.sort(((t,e)=>t.a-e.a)),t[a]=s}this.moveplanesets=t,this.moveplanenormals=e;const s=t.map((t=>t.length));this.verbose&&console.log("# Move plane sets: "+s);const i=[];for(let a=0;a<t.length;a++)i.push([]);for(let a=0;a<this.rotations.length;a++){const s=this.rotations[a];if(Math.abs(Math.abs(s.a)-1)<1e-9)continue;const n=s.makenormal();for(let o=0;o<t.length;o++)if(n.sameplane(e[o])){i[o].push(s);break}}this.moverotations=i;for(let a=0;a<i.length;a++){const t=i[a],s=t[0].makenormal();for(let e=0;e<t.length;e++)s.dist(t[e].makenormal())>1e-9&&(t[e]=t[e].smul(-1));t.sort(((t,e)=>t.angle()-e.angle())),i[a][0].dot(e[a])<0&&t.reverse()}const n=i.map((t=>1+t.length));this.movesetorders=n;const o=[];let r="?";for(let U=0;U<t.length;U++){const s=e[U];let i=null,n=null;for(let t=0;t<this.geonormals.length;t++){const e=s.dot(this.geonormals[t][0]);Math.abs(e-1)<1e-9?(n=[this.geonormals[t][1],this.geonormals[t][2]],r=this.geonormals[t][2]):Math.abs(e+1)<1e-9&&(i=[this.geonormals[t][1],this.geonormals[t][2]],r=this.geonormals[t][2])}if(null===n||null===i)throw new Error("Saw positive or negative sides as null");o.push([n[0],n[1],i[0],i[1],1+t[U].length]),"NxNxNCubeMapper"===this.addNotationMapper&&"f"===r&&(this.notationMapper=new u(1+t[U].length),this.addNotationMapper=""),"SkewbMapper"===this.addNotationMapper&&1===t[0].length&&(this.notationMapper=new R(this.swizzler),this.addNotationMapper=""),"PyraminxOrTetraminxMapper"===this.addNotationMapper&&(2===t[0].length&&.333333333333333===t[0][0].a&&1.66666666666667===t[0][1].a?(this.notationMapper=new v(this.swizzler),this.addNotationMapper=""):(this.notationMapper=new w(this.swizzler),this.addNotationMapper="")),"MegaminxMapper"===this.addNotationMapper&&"f"===r&&(1+t[U].length===3&&(this.notationMapper=new f(this.notationMapper)),this.addNotationMapper=""),"FTOMapper"===this.addNotationMapper&&"f"===r&&(1+t[U].length===3&&(this.notationMapper=new a(this.notationMapper,this.swizzler)),this.addNotationMapper="")}this.movesetgeos=o;const h={},l={},c={},m=[],p=[],d=this.faces;for(let a=0;a<d.length;a++){const t=d[a],e=this.keyface(t);if(h[e]||(c[e]=p.length,m.push(e),h[e]=[],l[e]=[],p.push(h[e])),l[e].push(a),h[e].push(t),l[e].length===this.basefacecount){this.verbose&&console.log("# Splitting core.");for(let t=0;t<this.basefacecount;t++){const s=e+" "+t;l[s]=[l[e][t]],h[s]=[h[e][t]],m.push(s),c[s]=p.length,p.push(h[s])}h[e]=[],p[c[e]]=[]}}this.cubiekey=c,this.facelisthash=l,this.cubiekeys=m,this.verbose&&console.log("# Cubies: "+Object.keys(h).length),this.cubies=p;for(let a=0;a<p.length;a++){const t=p[a];if(t.length<2)continue;if(t.length===this.basefacecount)continue;if(t.length>5)throw new Error("Bad math; too many faces on this cubie "+t.length);const e=t.map((t=>j(t))),s=l[this.keyface2(e[0])],i=j(e);for(let r=0;t.length>2;r++){let n=!1;for(let o=0;o<t.length;o++){const r=(o+1)%t.length;if(i.dot(e[o].cross(e[r]))<0){const i=t[o];t[o]=t[r],t[r]=i;const h=e[o];e[o]=e[r],e[r]=h;const l=s[o];s[o]=s[r],s[r]=l,n=!0}}if(!n)break;if(r>1e3)throw new Error("Bad epsilon math; too close to border")}let n=0,o=this.findface(t[n]);for(let r=1;r<t.length;r++){const e=this.findface(t[r]);this.faceprecedence[this.getfaceindex(e)]<this.faceprecedence[this.getfaceindex(o)]&&(n=r,o=e)}if(0!==n){const e=t.slice(),i=s.slice();for(let o=0;o<t.length;o++)t[o]=e[(n+o)%t.length],s[o]=i[(n+o)%t.length]}}const g=[];for(let a=0;a<p.length;a++){const t=l[m[a]];for(let e=0;e<t.length;e++)g[t[e]]=[a,e]}this.facetocubies=g;const b=["?","CENTERS","EDGES","CORNERS","C4RNER","C5RNER"],y=[],x=[0,0,0,0,0,0],z=[],M=[];let L=0;const k=[],F=[],B=[],D=[],E=t=>p[t].map((t=>this.getfaceindex(this.findface(t)))).join(" "),C=[];for(let a=0;a<p.length;a++){if(M[a])continue;const t=p[a];if(0===t.length)continue;const e={};let s=0;B.push(0),C.push([]);const n=t.length,o=x[n]++;let r=b[n];void 0!==r&&n!==this.basefacecount||(r="CORE"),r+=0===o?"":o+1,y[L]=r,z[L]=n;const h=[a];let l=0;for(M[a]=!0;l<h.length;){const n=h[l++],o=E(n);if((t.length>1||void 0===e[o])&&(e[o]=s++),D[n]=e[o],k[n]=L,C[L].push(n),F[n]=B[L]++,h.length<this.rotations.length){const t=j(p[n][0]);for(let e=0;e<i.length;e++){const s=this.facetocubies[this.findface2(t.rotatepoint(i[e][0]))][0];M[s]||(h.push(s),M[s]=!0)}}}const c=this;h.sort((function(t,e){return c.cubiekeys[t]<c.cubiekeys[e]?1:c.cubiekeys[t]>c.cubiekeys[e]?-1:0}));for(let i=0;i<h.length;i++)i>1e6&&(F[h[i]]=i);L++}if(this.setReidOrder&&4<=this.stickersperface&&this.stickersperface<=9){const t=[["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],["UFR","URB","UBL","ULF","DRF","DFL","DLB","DBR"],["U","L","F","R","B","D"]],e={};for(let s=0;s<t.length;s++)for(let i=0;i<t[s].length;i++){let n=0;for(let e=0;e<t[s][i].length;e++)n|=1<<t[s][i].charCodeAt(e)-65;e[n]=i}for(let s=0;s<L;s++)for(let t=0;t<C[s].length;t++){const i=C[s][t];let n=0;for(let t=0;t<p[i].length;t++)n|=1<<this.facenames[this.getfaceindex(this.findface(p[i][t]))][1].charCodeAt(0)-65;F[i]=e[n]}}if(this.orbits=B.length,this.cubiesetnums=k,this.cubieordnums=F,this.cubiesetnames=y,this.cubieords=B,this.orbitoris=z,this.cubievaluemap=D,this.cubiesetcubies=C,""!==this.fixPiece){for(let t=0;t<p.length;t++)if("v"===this.fixPiece&&p[t].length>2||"e"===this.fixPiece&&2===p[t].length||"f"===this.fixPiece&&1===p[t].length){this.fixedCubie=t;break}if(this.fixedCubie<0)throw new Error("Could not find a cubie of type "+this.fixPiece+" to fix.")}this.verbose&&console.log("# Cubie orbit sizes "+B)}unswizzle(t){const e=this.notationMapper.notationToInternal(t);return null===e?"":this.swizzler.unswizzle(e.family)}stringToBlockMove(s){const i=RegExp("^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$"),n=s.match(i);if(null===n)throw new Error("Bad move passed "+s);const o=n[4];let r,h;if(void 0!==n[2]){if(void 0===n[3])throw new Error("Missing second number in range");r=parseInt(n[2],10)}void 0!==n[3]&&(h=parseInt(n[3],10));let l="1",a=1;return void 0!==n[5]&&(l=n[5],"'"===l[0]&&(l="-"+l.substring(1)),a=parseInt(l,10)),new e(new t(o,h,r),a)}parseMove(t){const e=this.notationMapper.notationToInternal(t);if(null===e)throw new Error("Bad move "+t.family);let s,i=(t=e).family,n=!1;if(i.endsWith("v")&&i[0]<="Z"){if(void 0!==t.innerLayer||void 0!==t.outerLayer)throw new Error("Cannot use a prefix with full cube rotations");i=i.slice(0,-1),n=!0}i.endsWith("w")&&i[0]<="Z"&&(i=i.slice(0,-1).toLowerCase());let o=-1;const r=this.swizzler.unswizzle(i);let h=!1;for(let c=0;c<this.movesetgeos.length;c++){const t=this.movesetgeos[c];r===t[0]&&(h=!0,s=t,o=c),r===t[2]&&(h=!1,s=t,o=c)}let l=1,a=1;if(i.toUpperCase()!==i&&(a=2),void 0===s)throw new Error("Bad grip in move "+t.family);if(void 0!==t.outerLayer&&(l=t.outerLayer),void 0!==t.innerLayer&&(void 0===t.outerLayer?(a=t.innerLayer,l=i<="Z"?a:1):a=t.innerLayer),l--,a--,n&&(l=0,a=this.moveplanesets[o].length),l<0||l>this.moveplanesets[o].length||a<0||a>this.moveplanesets[o].length)throw new Error("Bad slice spec "+l+" "+a+" vs "+this.moveplanesets[o].length);if(0===l&&a===this.moveplanesets[o].length&&!n)throw new Error("! full puzzle rotations must be specified with v suffix.");return[void 0,o,l,a,h,t.amount]}parsemove(t){const e=this.parseMove(this.stringToBlockMove(t));return e[0]=t,e}genperms(){if(this.cmovesbyslice.length>0)return;const t=[];if(this.orientCenters)for(let e=0;e<this.cubies.length;e++)if(1===this.cubies[e].length){const t=this.findface(this.cubies[e][0]),s=this.getfaceindex(t);if(j(this.basefaces[s]).dist(this.facecentermass[t])<1e-9){const i=this.basefaces[s].length;for(let t=0;t<i;t++)this.cubies[e].push(this.cubies[e][0]);this.duplicatedFaces[t]=i,this.duplicatedCubies[e]=i,this.orbitoris[this.cubiesetnums[e]]=i}}for(let e=0;e<this.moveplanesets.length;e++){const s=this.moveplanesets[e],i=[],n=[s.length+1,0];let o=1;for(;2*o<=s.length;)o*=2;for(let t=0;t<this.faces.length;t++){let e=0;if(s.length>0){const i=this.facecentermass[t].dot(s[0]);for(let t=o;t>0;t>>=1)e+t<=s.length&&i>s[e+t-1].a&&(e+=t);e=s.length-e}for(i.push(e);n.length<=e;)n.push(0);n[e]++}const r=new Array(n.length);for(let t=0;t<n.length;t++)r[t]=[];const h=[];for(let t=0;t<this.faces.length;t++){if(i[t]<0)continue;const s=this.facetocubies[t].slice();let n=this.facecentermass[t];const o=n;let l=t;const a=i[l];for(;;){i[l]=-1;const t=n.rotatepoint(this.moverotations[e][0]);if(t.dist(o)<1e-9)break;l=this.findface2(t);const r=this.facetocubies[l];s.push(r[0],r[1]),n=t}if(s.length>2&&this.orientCenters&&(1===this.cubies[s[0]].length||this.cubies[s[0]][0]===this.cubies[s[0]][1])&&this.facecentermass[t].dist(j(this.basefaces[this.getfaceindex(t)]))<1e-9){let t=this.cubies[s[0]][0];for(let i=0;i<s.length;i+=2){const n=this.cubies[s[i]][0];let o=-1;for(let e=0;e<t.length;e++)if(n[e].dist(t[0])<1e-9){o=e;break}if(o<0)throw new Error("Couldn't find rotation of center faces; ignoring for now.");s[i+1]=o,t=this.moverotations[e][0].rotateface(t)}}if(2===s.length&&this.orientCenters)for(let t=1;t<this.movesetorders[e];t++)0===a?s.push(s[0],t):s.push(s[0],(this.movesetorders[e]-t)%this.movesetorders[e]);if(s.length>2&&!h[s[0]]){if(s.length!==2*this.movesetorders[e])throw new Error("Bad length in perm gen");for(let t=0;t<s.length;t++)r[a].push(s[t])}for(let t=0;t<s.length;t+=2)h[s[t]]=!0}t.push(r)}if(this.cmovesbyslice=t,void 0!==this.movelist){const t=[];for(let e=0;e<this.movelist.length;e++)t.push(this.parsemove(this.movelist[e]));this.parsedmovelist=t}this.facelisthash=null,this.facecentermass=[],this.cubiekey=[]}getfaces(){return this.faces.map((t=>t.map((t=>[t.b,t.c,t.d]))))}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(t){const e=this.moveplanesets[t].length;let s=[];if(void 0!==this.parsedmovelist)for(let i=0;i<this.parsedmovelist.length;i++){const n=this.parsedmovelist[i];n[1]===t&&(n[4]?s.push([n[2],n[3]]):s.push([e-n[3],e-n[2]]),s.push(n[5]))}else if(this.vertexmoves&&!this.allmoves){const i=this.movesetgeos[t];if(i[1]!==i[3])for(let t=0;t<e;t++)"v"!==i[1]?(this.outerblockmoves?s.push([t+1,e]):s.push([t+1]),s.push(1)):(this.outerblockmoves?s.push([0,t]):s.push([t,t]),s.push(1))}else for(let i=0;i<=e;i++)(this.allmoves||i+i!==e)&&(this.outerblockmoves?i+i>e?s.push([i,e]):s.push([0,i]):s.push([i,i]),s.push(1));if(this.fixedCubie>=0){const i=+this.cubiekeys[this.fixedCubie].trim().split(" ")[t],n=[];for(let t=0;t<s.length;t+=2){let o=s[t];if(i>=o[0]&&i<=o[1])if(0===o[0])o=[o[1]+1,e];else{if(e!==o[1])throw Error("fixed cubie option would disconnect move");o=[0,o[0]-1]}let r=!1;for(let e=0;e<n.length;e+=2)if(n[e][0]===o[0]&&n[e][1]===o[1]&&n[e+1]===s[t+1]){r=!0;break}r||(n.push(o),n.push(s[t+1]))}s=n}return s}graybyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&(this.graycenters||!this.centersets)||2===e&&(this.grayedges||!this.edgesets)||e>2&&(this.graycorners||!this.cornersets)}skipbyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&!this.centersets||2===e&&!this.edgesets||e>2&&!this.cornersets}skipcubie(t){return this.skipbyori(t)}skipset(t){if(0===t.length)return!0;const e=t[0];return this.skipbyori(this.facetocubies[e][0])}header(t){return t+"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\n"+t+this.args+"\n"}writegap(){const t=this.getOrbitsDef(!1),e=[],s=[];for(let n=0;n<t.moveops.length;n++){let i="M_"+D(this.notationMapper,t.movenames[n]),o=!1;"'"===i[i.length-1]&&(i=i.substring(0,i.length-1),o=!0),s.push(i),o?e.push(i+":="+t.moveops[n].toPerm().inv().toGap()+";"):e.push(i+":="+t.moveops[n].toPerm().toGap()+";")}e.push("Gen:=["),e.push(s.join(",")),e.push("];");const i=t.solved.identicalPieces();return e.push("ip:=["+i.map((t=>"["+t.map((t=>t+1)).join(",")+"]")).join(",")+"];"),e.push(""),this.header("# ")+e.join("\n")}writeksolve(t="PuzzleGeometryPuzzle"){const e=this.getOrbitsDef(!1);return this.header("# ")+e.toKsolve(t,this.notationMapper).join("\n")}writekpuzzle(t=!0){const e=this.getOrbitsDef(t),s=e.toKpuzzle();return s.moveNotation=new ot(this,e),s}getMoveFromBits(t,e,s,i,r,h){const l=[],a=[],c=[];for(let m=0;m<this.cubiesetnames.length;m++)a.push(o(this.cubieords[m])),c.push(n(this.cubieords[m]));for(let n=t[0];n<=t[1];n++){const t=i[n];for(let e=0;e<t.length;e+=2*h){const i=t.slice(e,e+2*h),n=this.cubiesetnums[i[0]];for(let t=0;t<i.length;t+=2)i[t]=this.cubieordnums[i[t]];let r=2,l=3;s&&(r=i.length-2,l=i.length-1),a[n]===o(this.cubieords[n])&&(a[n]=a[n].slice(),this.orbitoris[n]>1&&!this.killorientation&&(c[n]=c[n].slice()));for(let t=0;t<i.length;t+=2)a[n][i[(t+r)%i.length]]=i[t],this.orbitoris[n]>1&&!this.killorientation&&(c[n][i[t]]=(i[(t+l)%i.length]-i[(t+1)%i.length]+2*this.orbitoris[n])%this.orbitoris[n])}}let f=new U(o(24),n(24),1);for(let n=0;n<this.cubiesetnames.length;n++)if(!r||r[n])if(1===this.orbitoris[n]||this.killorientation)a[n]===o(f.perm.length)?(a[n]!==f.perm&&(f=new U(a[n],c[n],1)),l.push(f)):l.push(new U(a[n],c[n],1));else{const t=new Array(c[n].length);for(let e=0;e<a[n].length;e++)t[e]=c[n][a[n][e]];l.push(new U(a[n],t,this.orbitoris[n]))}let u=new S(l);return 1!==e&&(u=u.mulScalar(e)),u}omitSet(t){for(let e=0;e<this.omitsets.length;e++)if(this.omitsets[e]===t)return!0;return!1}diffmvsets(t,e,s,i){for(let n=0;n<t.length;n+=2){let o=!1;for(let r=0;!o&&r<e.length;r+=2)i?t[n][0]+e[r][1]===s&&t[n][1]+e[r][0]===s&&t[n+1]===e[r+1]&&(o=!0):t[n][0]===e[r][0]&&t[n][1]===e[r][1]&&t[n+1]===e[r+1]&&(o=!0);if(!o)return!0}return!1}getOrbitsDef(t){const e=[];if(t)for(let c=0;c<this.cubiesetnames.length;c++)e.push(1);const s=[],i=[],n=[],o=[];for(let c=0;c<this.moveplanesets.length;c++){const t=this.getmovesets(c);n.push(t),this.addrotations?o.push(1):o.push(0)}if(this.movelist&&this.addrotations){for(let t=0;t<this.moverotations.length;t++)o[t]=0;for(let t=0;t<this.moveplanesets.length;t++)for(let e=0;e<this.moverotations.length;e++){let s=this.moveplanenormals[t];for(let i=1;2*i<=this.movesetorders[e];i++){if(s=s.rotatepoint(this.moverotations[e][0]),o[e]&i)continue;let r=-1,h=!1;for(let t=0;r<0&&t<this.moveplanenormals.length;t++)s.dist(this.moveplanenormals[t])<1e-9?r=t:s.dist(this.moveplanenormals[t].smul(-1))<1e-9&&(r=t,h=!0);if(r<0)throw new Error("Could not find rotation");let l=n[r];(l.length!==n[t].length||this.moveplanesets[t].length!==this.moveplanesets[r].length||this.diffmvsets(l,n[t],this.moveplanesets[r].length,h))&&(o[e]|=i)}}for(let t=0;t<this.moverotations.length;t++)if(0===o[t])o[t]=1;else if(1===o[t])this.movesetorders[t]>3?o[t]=2:o[t]=0;else{if(3!==o[t])throw new Error("Impossible addrot val");o[t]=0}}for(let c=0;c<this.moveplanesets.length;c++)0!==o[c]&&(n[c].push([0,this.moveplanesets[c].length]),n[c].push(o[c]));for(let c=0;c<this.moveplanesets.length;c++){const t=n[c],s=this.movesetorders[c];for(let e=0;e<t.length;e+=2)for(let s=0;s<e;s+=2)if(t[e]===t[s]&&t[e+1]===t[s+1])throw new Error("Redundant moves in moveset.");const i=[];for(let e=0;e<t.length;e+=2)for(let s=t[e][0];s<=t[e][1];s++)i[s]=1;const o=this.cmovesbyslice[c];for(let n=0;n<o.length;n++){if(1!==i[n])continue;const t=o[n];for(let i=0;i<t.length;i+=2*s){if(this.skipcubie(t[i]))continue;e[this.cubiesetnums[t[i]]]=1}}}for(let c=0;c<this.cubiesetnames.length;c++)e[c]&&(this.omitSet(this.cubiesetnames[c])?e[c]=0:(s.push(this.cubiesetnames[c]),i.push(new B(this.cubieords[c],this.killorientation?1:this.orbitoris[c]))));const r=[];for(let c=0;c<this.cubiesetnames.length;c++){if(!e[c])continue;if(this.omitSet(this.cubiesetnames[c]))continue;const s=[],i=[];for(let e=0;e<this.cubieords[c];e++){if(t)s.push(e);else{const t=this.cubiesetcubies[c][e];s.push(this.cubievaluemap[t])}i.push(0)}r.push(new U(s,i,this.killorientation?1:this.orbitoris[c]))}const h=[],l=[];for(let c=0;c<this.moveplanesets.length;c++){const t=this.moveplanesets[c].length,s=n[c],i=this.movesetgeos[c];for(let n=0;n<s.length;n+=2){const o=s[n],r=Y(i,o,t),a=r[0],f=r[1];1===s[n+1]?h.push(a):h.push(a+s[n+1]);const u=this.getMoveFromBits(o,s[n+1],f,this.cmovesbyslice[c],e,this.movesetorders[c]);l.push(u)}}this.ksolvemovenames=h;let a=new E(s,i,new I(r),h,l);return this.optimize&&(a=a.optimize()),0!==this.scramble&&a.scramble(this.scramble),a}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map((t=>t.toPerm()))}showcanon(t){!function(t,e){const s=t.moveops.length;if(s>30)throw new Error("Canon info too big for bitmask");const i=[],n=[];for(let r=0;r<s;r++){const e=t.moveops[r];i.push(e.order());let o=0;for(let i=0;i<s;i++){if(i===r)continue;const s=t.moveops[i];e.mul(s).equal(s.mul(e))&&(o|=1<<i)}n.push(o)}let o={0:1};for(let r=0;r<100;r++){let t=0;const s={};let h=0;for(const e in o){const r=+e,l=o[r];t+=l,h++;for(let t=0;t<i.length;t++)if(0==(r>>t&1)&&0==(r&n[t]&(1<<t)-1)){const e=r&n[t]|1<<t;void 0===s[e]&&(s[e]=0),s[e]+=(i[t]-1)*l}}e(r+": canonseq "+t+" states "+h),o=s}}(this.getOrbitsDef(!1),t)}getsolved(){const t=[];for(let e=0;e<this.basefacecount;e++)for(let s=0;s<this.stickersperface;s++)t.push(e);return new h(t)}getOrientationRotation(t){const e=t[0],s=new K(0,t[1][0],-t[1][1],t[1][2]),i=t[2],n=new K(0,t[3][0],-t[3][1],t[3][2]);let o=null,r=null;const h=this.swizzler.unswizzle(e),l=this.swizzler.unswizzle(i);for(const c of this.geonormals)h===c[1]&&(o=c[0]),l===c[1]&&(r=c[0]);if(!o)throw new Error("Could not find feature "+e);if(!r)throw new Error("Could not find feature "+i);const a=o.pointrotation(s);return r.rotatepoint(a).unproject(s).pointrotation(n.unproject(s)).mul(a)}getInitial3DRotation(){const t=this.basefacecount;let e=null;if(this.puzzleOrientation?e=this.puzzleOrientation:this.puzzleOrientations&&(e=this.puzzleOrientations[t]),e||(e={4:["FLR",[0,1,0],"F",[0,0,1]],6:["U",[0,1,0],"F",[0,0,1]],8:["U",[0,1,0],"F",[0,0,1]],12:["U",[0,1,0],"F",[0,0,1]],20:["GUQMJ",[0,1,0],"F",[0,0,1]]}[t]),!e)throw new Error("No default orientation?");return this.getOrientationRotation(e)}generatesvg(t=800,e=500,s=10,i=!1){function n(t,e){let s=t[1][0]-t[0][0],i=t[1][1]-t[0][1];const n=2*Math.PI/e,o=Math.cos(n),r=Math.sin(n);for(let h=2;h<e;h++){const e=s*o+i*r;i=i*o-s*r,s=e,t.push([t[h-1][0]+s,t[h-1][1]+i])}}function o(t){return t+0*(Math.random()-.5)}function r(t,e,s){return'<polygon id="'+t+'" class="sticker" style="fill: '+s+'" points="'+e.map((t=>o(t[0])+" "+o(t[1]))).join(" ")+'"/>\n'}t-=2*s,e-=2*s;let h=this.addrotations,l=this.addrotations,a=this.addrotations;for(let O=0;O<this.movesetgeos.length;O++){const t=this.movesetgeos[O];for(let e=1;e<=3;e+=2)"v"===t[e]&&(h=!0),"f"===t[e]&&(a=!0),"e"===t[e]&&(l=!0)}this.genperms();const c=this.getboundarygeometry().facenames[0][0].length,f=this.net;if(null===f)throw new Error("No net?");const u={};let m=0,p=0,d=1,g=0;u[f[0][0]]=[[1,0],[0,0]],n(u[f[0][0]],c);for(let O=0;O<f.length;O++){const t=f[O][0];if(!u[t])throw new Error("Bad edge description; first edge not connected.");for(let e=1;e<f[O].length;e++){const s=f[O][e];""===s||u[s]||(u[s]=[u[t][e%c],u[t][(e+c-1)%c]],n(u[s],c))}}for(const O in u){const t=u[O];for(let e=0;e<t.length;e++)m=Math.min(m,t[e][0]),d=Math.max(d,t[e][0]),p=Math.min(p,t[e][1]),g=Math.max(g,t[e][1])}const b=Math.min(t/(d-m),e/(g-p)),v=.5*(t-b*(d+m)),w=.5*(e-b*(g+p)),y={},x=this.getboundarygeometry(),z={},M=[[b+v,w],[v,w]];z[f[0][0]]=M,n(z[f[0][0]],c),y[this.facenames[0][1]]=this.project2d(0,0,[new K(0,M[0][0],M[0][1],0),new K(0,M[1][0],M[1][1],0)]);const L=[];L[0]=0;for(let O=0;O<f.length;O++){const t=f[O][0];if(!z[t])throw new Error("Bad edge description; first edge not connected.");let e=-1;for(let i=0;i<x.facenames.length;i++)if(t===x.facenames[i][1]){e=i;break}if(e<0)throw new Error("Could not find first face name "+t);const s=x.facenames[e][0];for(let i=1;i<f[O].length;i++){const o=f[O][i];if(""===o||z[o])continue;z[o]=[z[t][i%c],z[t][(i+c-1)%c]],n(z[o],c);const r=L[e],h=s[(r+i)%c].sum(s[(r+i+c-1)%c]).smul(.5),l=J(x.edgenames,h),a=tt(x.edgenames[l][1],this.facenames),u=a[t===a[0]?1:0];let m=-1;for(let t=0;t<x.facenames.length;t++)if(u===x.facenames[t][1]){m=t;break}if(m<0)throw new Error("Could not find second face name");const p=x.facenames[m][0];for(let e=0;e<p.length;e++){if(p[e].sum(p[(e+1)%c]).smul(.5).dist(h)<=1e-9){const s=z[t][(i+c-1)%c],n=z[t][i%c];L[m]=e,y[u]=this.project2d(m,e,[new K(0,n[0],n[1],0),new K(0,s[0],s[1],0)]);break}}}}const k=this.getsolved(),F=[],R=[];for(let O=0;O<this.basefacecount;O++)F[O]=this.colors[this.facenames[O][1]];let B=0,D=0;const E=this.getInitial3DRotation();for(let O=0;O<this.faces.length;O++){let t=this.faces[O];t=E.rotateface(t);for(let e=0;e<t.length;e++)B=Math.max(B,Math.abs(t[e].b)),D=Math.max(D,Math.abs(t[e].c))}const C=Math.min(e/D/2,(t-s)/B/4),U=(n,o)=>{if(i){const i=.5*s+.25*t,r=this.baseplanes[n].rotateplane(E).d<0?1:-1;return[s+.5*t+r*(i-o.b*C),s+.5*e+o.c*C]}{const t=y[this.facenames[n][1]];return[s+o.dot(t[0])+t[2].b,s+e-o.dot(t[1])-t[2].c]}};for(let O=0;O<this.faces.length;O++){let t=this.faces[O];const e=Math.floor(O/this.stickersperface);i&&(t=E.rotateface(t)),R.push(t.map((t=>U(e,t))))}const N=[];for(let O=0;O<this.basefacecount;O++){N.push("<g>"),N.push("<title>"+this.facenames[O][1]+"</title>\n");for(let t=0;t<this.stickersperface;t++){const e=O*this.stickersperface+t,s=this.facetocubies[e][0],i=this.facetocubies[e][1],n=this.cubiesetnums[s],o=this.cubieordnums[s],h=this.graybyori(s)?"#808080":F[k.p[e]];let l=this.cubiesetnames[n]+"-l"+o+"-o"+i;if(N.push(r(l,R[e],h)),this.duplicatedFaces[e])for(let t=1;t<this.duplicatedFaces[e];t++)l=this.cubiesetnames[n]+"-l"+o+"-o"+t,N.push(r(l,R[e],h))}N.push("</g>")}const S=[];function I(t,e,s,i){const n=U(t,s);for(let o=0;o<S.length;o++)if(Math.hypot(n[0]-S[o][0],n[1]-S[o][1])<1e-9)return;S.push([n[0],n[1],e,i])}for(let O=0;O<this.faceplanes.length;O++){const t=this.facenames[O][0];let e=t;if(i&&(e=E.rotateface(e)),a){let t=this.faceplanes[O][0];i&&(t=t.rotatepoint(E)),I(O,this.faceplanes[O][1],t,c)}for(let s=0;s<t.length;s++){if(l){const i=t[s].sum(t[(s+1)%t.length]).smul(.5),n=J(this.edgenames,i),o=e[s].sum(e[(s+1)%t.length]).smul(.5);I(O,this.edgenames[n][1],o,2)}if(h){const i=J(this.vertexnames,t[s]);I(O,this.vertexnames[i][1],e[s],this.cornerfaces)}}}const T='<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">\n<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\n'+N.join("")+"</svg>";return this.svggrips=S,T}dist(t,e){return Math.hypot(t[0]-e[0],t[1]-e[1],t[2]-e[2])}triarea(t,e,s){const i=this.dist(t,e),n=this.dist(e,s),o=this.dist(t,s),r=(i+n+o)/2;return Math.sqrt(r*(r-i)*(r-n)*(r-o))}polyarea(t){let e=0;for(let s=2;s<t.length;s++)e+=this.triarea(t[0],t[1],t[s]);return e}get3d(t=.77,e){const s=[],i=[],n=this.getInitial3DRotation(),o=[],r=.52*this.basefaces[0][0].len();let h=0;for(let c=0;c<this.basefaces.length;c++){const t=n.rotateface(this.basefaces[c]),e=this.facenames[c][1];o.push({coords:st(t,r),name:e}),h+=this.polyarea(o[c].coords)}h/=this.faces.length;const l=Math.sqrt(h)*(1-Math.sqrt(t))/2;for(let c=0;c<this.faces.length;c++){const t=Math.floor(c/this.stickersperface),o=this.facetocubies[c][0],h=this.facetocubies[c][1],a=this.cubiesetnums[o],f=this.cubieordnums[o];let u=this.graybyori(o)?"#808080":this.colors[this.facenames[t][1]];(null==e?void 0:e.stickerColors)&&(u=e.stickerColors[c]);let m=n.rotateface(this.faces[c]);i.push({coords:st(m,r),color:u,orbit:this.cubiesetnames[a],ord:f,ori:h});const p=m;if(l&&l>0&&(m=it(m,l)),s.push({coords:st(m,r),color:u,orbit:this.cubiesetnames[a],ord:f,ori:h}),this.duplicatedFaces[c])for(let e=1;e<this.duplicatedFaces[c];e++)s.push({coords:st(m,r),color:u,orbit:this.cubiesetnames[a],ord:f,ori:e}),i.push({coords:st(p,r),color:u,orbit:this.cubiesetnames[a],ord:f,ori:e})}const a=[];for(let c=0;c<this.movesetgeos.length;c++){const t=this.movesetgeos[c],e=this.movesetorders[c];for(let s=0;s<this.geonormals.length;s++){const i=this.geonormals[s];t[0]===i[1]&&t[1]===i[2]&&(a.push([et(i[0].rotatepoint(n),1),t[0],e]),a.push([et(i[0].rotatepoint(n).smul(-1),1),t[2],e]))}}return{stickers:s,foundations:i,faces:o,axis:a,unswizzle:function(t){return this.unswizzle(t)}.bind(this),notationMapper:this.notationMapper}}getGeoNormal(t){const e=this.getInitial3DRotation(),s=this.swizzler.unswizzle(t);for(let i=0;i<this.geonormals.length;i++){const t=this.geonormals[i];if(s===t[1]){const s=et(t[0].rotatepoint(e),1);return Math.abs(s[0])<1e-9&&Math.abs(s[2])<1e-9&&(s[0]=0,s[2]=1e-6),s}}}getfaceindex(t){const e=this.stickersperface;return Math.floor(t/e)}},ot=class{constructor(t,e){this.pg=t,this.cache={},this.orbitNames=e.orbitnames}lookupMove(t){const e=this.moveToKeyString(t);if(e in this.cache)return this.cache[e];const s=this.pg.parseMove(t);if(this.pg.parsedmovelist){let t=!1;for(let e=0;e<this.pg.parsedmovelist.length;e++)this.pg.parsedmovelist[e][1]===s[1]&&this.pg.parsedmovelist[e][2]===s[2]&&this.pg.parsedmovelist[e][3]===s[3]&&this.pg.parsedmovelist[e][4]===s[4]&&(t=!0);if(!t)return}let i=[s[2],s[3]];if(!s[4]){const t=this.pg.moveplanesets[s[1]].length;i=[t-s[3],t-s[2]]}const n=this.pg.getMoveFromBits(i,s[5],!s[4],this.pg.cmovesbyslice[s[1]],void 0,this.pg.movesetorders[s[1]]),o=E.transformToKPuzzle(this.orbitNames,n);return this.cache[e]=o,o}moveToKeyString(t){let e="";return t.outerLayer&&(e=e+t.outerLayer+","),t.innerLayer&&(e=e+t.innerLayer+","),e=e+t.family+","+t.amount,e}};function rt(t,e){let s=0;for(;s<t.length&&"-"===t[s][0];){const i=t[s++];if("--rotations"===i)e.push("rotations",!0);else if("--allmoves"===i)e.push("allmoves",!0);else if("--outerblockmoves"===i)e.push("outerblockmoves",!0);else if("--vertexmoves"===i)e.push("vertexmoves",!0);else if("--nocorners"===i)e.push("cornersets",!1);else if("--noedges"===i)e.push("edgesets",!1);else if("--noorientation"===i)e.push("killorientation",!0);else if("--nocenters"===i)e.push("centersets",!1);else if("--omit"===i)e.push("omit",t[s].split(",")),s++;else if("--moves"===i)e.push("movelist",t[s].split(",")),s++;else if("--optimize"===i)e.push("optimize",!0);else if("--scramble"===i)e.push("scramble",100);else if("--fixcorner"===i)e.push("fix","v");else if("--fixedge"===i)e.push("fix","e");else if("--fixcenter"===i)e.push("fix","f");else if("--orientcenters"===i)e.push("orientcenters",!0);else{if("--puzzleorientation"!==i)throw new Error("Bad option: "+i);e.push("puzzleorientation",t[s]),s++}}return s}var ht=class{constructor(){this.mult=[]}multiply(t){for(let e=2;e*e<=t;e++)for(;t%e==0;)void 0!==this.mult[e]?this.mult[e]++:this.mult[e]=1,t/=e;t>1&&(void 0!==this.mult[t]?this.mult[t]++:this.mult[t]=1)}toString(){let t="";for(let e=0;e<this.mult.length;e++)void 0!==this.mult[e]&&(""!==t&&(t+="*"),t+=e,this.mult[e]>1&&(t+="^"+this.mult[e]));return t}};function lt(t,e){const s=t[0].p.length,i=function(t){return new h(o(t))}(s);let n=[],r=[],l=[],a=[],c=[];function f(t,e,s){a[t].push(e),c[t].push(s);for(let i=0;i<n[t].length;i++)n[t][i]&&u(t,n[t][i].mul(e),s+l[t][i])}function u(t,e,s){const i=e.p[t];if(!n[t][i]){n[t][i]=e,r[t][i]=e.inv(),l[t][i]=s;for(let i=0;i<a[t].length;i++)u(t,e.mul(a[t][i]),s+c[t][i]);return}const o=e.mul(r[t][i]);(function(t){for(let e=t.p.length-1;e>=0;e--){const s=t.p[e];if(s!==e){if(!n[e][s])return!1;t=t.mul(r[e][s])}}return!0})(o)||f(t-1,o,s+l[t][i])}return function(){n=[],r=[],a=[],l=[],c=[];for(let t=0;t<s;t++)n.push([]),r.push([]),l.push([]),a.push([]),c.push([]),n[t][t]=i,r[t][t]=i,l[t][t]=0;let o=0,h=1;for(let i=0;i<t.length;i++){f(s-1,t[i],1),h=1;let r=0,c=0;const u=new ht;for(let t=0;t<s;t++){let e=0,i=0;for(let r=0;r<s;r++)n[t][r]&&(e++,i+=l[t][r],t!==r&&o++);r+=a[t].length,h*=e,e>1&&u.multiply(e);c+=i/e}e(i+": sz "+h+" T "+r+" sol "+c+" none "+o+" mults "+u)}return h}()}export{U as Orbit,B as OrbitDef,E as OrbitsDef,h as Perm,nt as PuzzleGeometry,K as Quat,S as Transformation,I as VisibleState,$ as getPuzzleGeometryByDesc,X as getPuzzleGeometryByName,V as getpuzzle,Q as getpuzzles,Z as parsedesc,rt as parseoptions,lt as schreierSims,H as useNewFaceNames};
